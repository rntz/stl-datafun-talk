\documentclass[xcolor=table,usenames,dvipsnames,svgnames]{beamer}

%% apparently this magic helps avoid the dreaded
%% ``Too many math alphabets used in version normal''
%% error. Yuk.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
%% end magic

\usepackage{amssymb,amsmath,amsthm}
\usepackage{latexsym}

\usepackage{array}

\usepackage{url}
\usepackage{hyperref}

%% uses the AMS Euler math font.
%% \usepackage{euler}

%% for coloneqq
%% \usepackage{mathtools}

%% %% for \underaccent
%% \usepackage{accents}

% for semantic brackets
%% \usepackage{stmaryrd}

%% % for inference rules
%% \usepackage{proof}

%% %% for mathpar environment
%% \usepackage{mathpartir}

% for \scalebox, \rotatebox
%% \usepackage{graphicx}

%% %% for drawing Hasse diagram
%% \usepackage{tikz}

%% %% for censoring things
%% \usepackage{censor}


%% configuration
%% I hate everything
\newcommand{\fixcolors}{\rowcolors{2}{white}{}}
\fixcolors


%% Commands
\newcommand{\N}{\mathbb{N}}
\newcommand{\x}{\times}

%% wherever you see this color, it means runnable Datafun code.
\newcommand{\df}{\color{RoyalBlue}}


%% Metadata
\title{Datafun}
\subtitle{a functional query language}
\author{Michael Arntzenius
  \newline\href{mailto:daekharel@gmail.com}{daekharel@gmail.com}
  \newline\url{http://www.rntz.net/datafun}}
\date{Strange Loop, September 2017}

\begin{document}

\maketitle


\begin{frame}\LARGE \centering
  %% TODO: grab pithier text from abstract
  \textbf{What if \textcolor{DarkOrchid}{programming languages}\\
    were more like \textcolor{DarkOrchid}{query languages}?}

  %% \vspace{2em}\pause

  %% \textbf{What if \textcolor{DarkOrchid}{query languages} were\\
  %%   more like \textcolor{DarkOrchid}{programming languages}?}
\end{frame}

\begin{frame}\Large
  \begin{enumerate}
    \itemsep 1.5em
  \item {\bf What's a functional query language?}
  \item From Datalog to Datafun
  \item Incremental Datafun
  \end{enumerate}
\end{frame}


\begin{frame}{SQL}\large
  \begin{minipage}{0.4\textwidth}
    \centering
    \begin{tabular}{l|l}
      \textbf{Parent} & \textbf{Child}\\\hline
      Arathorn & Aragorn\\
      Drogo & Frodo\\
      E\"arwen & Galadriel\\
      Finarfin & Galadriel\\
      \rowcolor{white}
      \hfill\vdots & \hfill\vdots
    \end{tabular}
  \end{minipage}
  %
  %% \pause
  \hfill
  %
  \begin{minipage}{0.51\textwidth}
    \texttt{SELECT parent\\FROM parentage\\WHERE child = "Galadriel"}
  \end{minipage}
\end{frame}


\begin{frame}{Tables as sets}\large
  \begin{minipage}{0.4\textwidth}
    \centering
    \begin{tabular}{l|l}
      \textbf{Parent} & \textbf{Child}\\\hline
      Arathorn & Aragorn\\
      Drogo & Frodo\\
      E\"arwen & Galadriel\\
      Finarfin & Galadriel\\
      \rowcolor{white}
      \hfill\vdots & \hfill\vdots
    \end{tabular}

    %% \vspace{1.5em}{\large \uncover<2>{\textsc{as a table}}}

  \end{minipage}
  %
  \hfill{\LARGE =}\hfill
  %
  \begin{minipage}{0.51\textwidth}
    \centering

    \begin{tabular}{l}
      \color{gray}{// set of (parent, child) pairs}\\
      \{\hspace{1pt}("Arathorn", Aragorn)\\
      , (Drogo, Frodo)\\
      , (E\"arwen, Galadriel)\\
      , (Finarfin, Galadriel)\\
      \,...\,\} \phantom{\vdots}
    \end{tabular}

    %% \vspace{1.5em}{\large \textsc{as a relation}}
  \end{minipage}

\end{frame}


\begin{frame}{Queries as set comprehensions}\Large\centering
  \begin{minipage}{0.7\textwidth}
    %% TODO: is ``parentage'' the best name?
    \texttt{SELECT parent\\FROM parentage\\WHERE child = "Galadriel"}
  \end{minipage}

  \vspace{1.5em}
  {\LARGE $\Longrightarrow$}
  \vspace{1em}

  \begin{minipage}{1.0\textwidth}
    \Large
    \df \tt \{ parent | (parent, child) in parentage\\
    \phantom{\{ parent }, child == "Galadriel" \}
    %% \tt \{ parent \\
    %% | (parent, child) in parentage\\
    %% , child == "Galadriel" \}
  \end{minipage}

  %% TODO: more examples
\end{frame}


\begin{frame}{Recipe for a functional query language}\Large
  %% \textbf{Recipe for a functional query language:}\vspace{0.5em}

  \begin{enumerate}\itemsep 1.5em
  \item Take a functional language
  \item Add sets and set comprehensions
  \item {\color{red} ... done?}
  \end{enumerate}
\end{frame}


\begin{frame}\centering{\bf\huge But can it go fast?}\end{frame}

\begin{frame}{Loop reordering}\large\centering
  \texttt{\alt<1>{\df}{}\{ (x,y) | x in \alt<4>{{\color{red}\{\}}}{EXPR1},
    y in \alt<4>{{\color{red}$\infty$-loop}}{EXPR2}\alt<4>{}{,
    \alt<3>{{\color{red}print x}}{...}}\}}
  \alt<4>{{\color{blue}$~\Longrightarrow~$\{\}}\phantom{-loo}\,}{}
  %
  \vspace{0.5em}\\
  {\Large \alt<1>{=?}{\color{red}$\neq$}}
  %
  \vspace{0.5em}\\
  \texttt{\alt<1>{\df}{}\{ (x,y) | y in \alt<4>{{\color{red}$\infty$-loop}}{EXPR2},
    x in \alt<4>{{\color{red}\{\}}}{EXPR1}\alt<4>{}{,
    \alt<3>{{\color{red}print x}}{...}}\}}
  \alt<4>{{\color{blue}$~\Longrightarrow~\infty$-loop}}{}

  \pause
  \vspace{3em}\Large
  \begin{minipage}{0.5\textwidth}
    \begin{enumerate}
    \item {\alt<3>{\color{red}}{} Side-effects}
    \item {\alt<4>{\color{red}}{} Nontermination}
    \end{enumerate}
  \end{minipage}
\end{frame}


\begin{frame}{Recipe for a functional query language, v2}\Large
  \begin{enumerate}\itemsep 1.5em
  \item Take a \textbf{pure, total} functional language
  \item Add sets and set comprehensions
  \item {\color{orange} Optimize!}
  \end{enumerate}
\end{frame}

%% TODO: slide about pros and cons / what we gained, what we lose
%% TODO: moar examples of Datafun


\begin{frame}\Large
  \begin{enumerate} \itemsep 1.5em \color{gray}
  \item What's a functional query language?
  \item {\color{black}\bf From Datalog to Datafun}
  \item Incremental Datafun
  \end{enumerate}
\end{frame}


\begin{frame} \large \centering
  \begin{minipage}{0.4\textwidth}
    \centering
    \begin{tabular}{l|l}
      \textbf{Parent} & \textbf{Child}\\\hline
      Arathorn & Aragorn\\
      Drogo & Frodo\\
      E\"arwen & Galadriel\\
      Finarfin & Galadriel\\
      \rowcolor{white}
      \hfill\vdots & \hfill\vdots
    \end{tabular}
  \end{minipage}

  \vspace{2em}

  %% robsimmons: ``It's worth having languages where the
  %% important ideas are foundational to the language.''
  %% use this?
  {\Large \bf Is E\"arendil one of Aragorn's ancestors?}

\end{frame}


\newcommand{\atom}[1]{\textcolor{brown}{#1}}
\begin{frame}{Datalog in a nutshell}
  \large
  \atom{\alt<2-3>{ancestor($X$,$Z$)}{$X$ is $Z$'s ancestor}}
  \alt<3>{:-}{if}
  \atom{\alt<2-3>{parent($X$, $Z$)}{$X$ is $Z$'s parent}}.
  \\\vspace{1em}
  \atom{\alt<2-3>{ancestor($X$, $Z$)}{$X$ is $Z$'s ancestor}}
  \alt<3>{:-}{if}
  \atom{\alt<2-3>{parent($X$, $Y$)}{$X$ is $Y$'s parent}}\alt<3>{,}{ and}
  \atom{\alt<2-3>{ancestor($Y$, $Z$)}{$Y$ is $Z$'s ancestor}}.

  %% \vspace{2em}
  %% \uncover<3>{\bf This is valid Datalog.}
\end{frame}

%% \begin{frame}\LARGE\centering
%%   \textbf{How can we do this\\ in a functional query language?}
%% \end{frame}


\begin{frame}\Large
  Datalog is \textbf{deductive}: it chases rules to their logical conclusions.
  \\\vspace{2em}
  Can we capture this feature \textbf{functionally}?
\end{frame}


\newcommand{\newfact}{\bf\color{Green}}
\newcommand{\used}{\bf\color{blue}}
\begin{frame}{}

  {
  \textbf{Procedure:}
  \begin{enumerate}\itemsep 0em
  \item Pick a rule.
  \item Find facts satisfying its premises.
  \item Add its conclusion to the known facts.
  \end{enumerate}}

  \textbf{Rules:}
  \begin{quote}\sf
    {\alt<2-4,6>{\used}{} ancestor(X,Z) :- parent(X,Z).}\\
    {\alt<8>{\used}{} ancestor(X,Z) :- parent(X,Y), ancestor(Y,Z).}\\
  \end{quote}

  \textbf{Facts:}
  \begin{quote}\sf
    {\alt<3-4,8>{\used}{} parent(Idril, E\"arendil).}\\
    {\alt<6>{\used}{} parent(E\"arendil, Elros).}\\
    \uncover<4->
    {\alt<4>{\newfact}{}ancestor(Idril, E\"arendil)\alt<4>{!}{.}}\\
    \uncover<6->
    {\alt<6>{\newfact}{}\alt<8>{\used}{}ancestor(E\"arendil, Elros)\alt<6>{!}{.}}\\
    \uncover<8->
    {\alt<8>{\newfact}{}{ancestor(Idril, Elros)\alt<8>{!}{.}}}
    \alt<9>{}{}
  \end{quote}
\end{frame}


\begin{frame}\Large
  Repeatedly apply a \textbf{\alt<2->{\alt<2>{\color{blue}}{}function}{set of rules}}\\
  until \textbf{\alt<3->{\alt<3>{\color{blue}}{}its output equals its input}{nothing changes}}\\
  \uncover<4->{i.e. it reaches a \textbf{\color{blue}fixed point}}{}

  \vspace{2em}

  \uncover<5->{\LARGE\centering\df fix x = {\it ... function of x ...}}
\end{frame}


\begin{frame}
  \Large

  \textcolor{gray}{\it // In Datalog}\\
  ancestor(X,Z) :- parent(X,Z).\\
  ancestor(X,Z) :- parent(X,Y), ancestor(Y,Z).

  \pause\vspace{2em}\df

  \textcolor{gray}{\it // In Datafun}\\
  fix ancestor = parent\newline
  \phantom{fix ancestor}
  %$\cup$ (parent $\bullet$ ancestor)
  $\cup$ \{(x,z) $\mid$ (x,y) in parent\newline
  \phantom{fix ancestor $\cup$ \{(x,z) }, (!y,z) in ancestor\}
\end{frame}

%% TODO: show how to run the Datafun code?


\begin{frame}\centering{\bf\huge But can it go fast?}\end{frame}
% And I'm afraid the only answer I can give to this question is
% ``I don't know yet.''
%
% But I am hopeful. And in the next section I'm going to show you one of the
% reasons I'm hopeful.


\begin{frame}\Large
  \begin{enumerate}\color{gray}\itemsep 1.5em
  \item What's a functional query language?
  \item From Datalog to Datafun
  \item {\color{black}\bf Incremental Datafun}
  \end{enumerate}
\end{frame}


\begin{frame}{Three problems}\large
  \begin{enumerate}\itemsep 1em
    \alt<4>{\color{gray}}{}
  \item {\bf View maintenance:} \\
    {\normalsize How do we update a cached query efficiently after an update?}\
    \pause
  \item {\bf Semina\"ive evaluation in Datalog:}\\
    {\normalsize How to avoid applying rules that generate facts we already know?}
    \pause
  \item \color{black}{\bf Incremental computation:}\\
    {\normalsize How to efficiently recompute a
    function's output when its input changes slightly?}
  \end{enumerate}
\end{frame}

\end{document}
