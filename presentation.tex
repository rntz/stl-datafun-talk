\documentclass[xcolor=table,usenames,dvipsnames,svgnames]{beamer}

%% apparently this magic helps avoid the dreaded
%% ``Too many math alphabets used in version normal''
%% error. Yuk.
\newcommand\hmmax{0}
\newcommand\bmmax{0}
%% end magic

\usepackage{amssymb,amsmath,amsthm}
\usepackage{latexsym}

\usepackage{array}

\usepackage{url}
\usepackage{hyperref}

%% uses the AMS Euler math font.
%% \usepackage{euler}

%% for coloneqq
%% \usepackage{mathtools}

%% %% for \underaccent
%% \usepackage{accents}

% for semantic brackets
%% \usepackage{stmaryrd}

%% % for inference rules
%% \usepackage{proof}

%% for mathpar environment
\usepackage{mathpartir}

% for \scalebox, \rotatebox
%% \usepackage{graphicx}

%% %% for drawing Hasse diagram
%% \usepackage{tikz}

%% %% for censoring things
%% \usepackage{censor}


%% configuration
%% I hate everything
\newcommand{\fixcolors}{\rowcolors{2}{white}{}}
\fixcolors


%% Commands
\newcommand{\N}{\mathbb{N}}
\newcommand{\x}{\times}

%% wherever you see this color, it means runnable Datafun code.
\newcommand{\df}{\color{RoyalBlue}}

\newcommand{\GD}{\Delta}


%% Metadata
\title{Datafun}
\subtitle{a functional query language}
\author{Michael Arntzenius
  \newline\href{mailto:daekharel@gmail.com}{daekharel@gmail.com}
  \newline\url{http://www.rntz.net/datafun}}
\date{Strange Loop, September 2017}

\begin{document}

\maketitle


\begin{frame}\centering\LARGE\bf Exploratory work \end{frame}

\begin{frame}\LARGE \centering
  \textbf{What if \textcolor{DarkOrchid}{programming languages}\\
    were more like \textcolor{DarkOrchid}{query languages}?}
\end{frame}

\begin{frame}\Large
  \begin{enumerate}
    \itemsep 1.5em
  \item {\bf What's a functional query language?}
  \item From Datalog to Datafun
  \item Incremental Datafun
  \end{enumerate}
\end{frame}


\begin{frame}{SQL}\large
  \begin{minipage}{0.4\textwidth}
    \centering
    \begin{tabular}{l|l}
      \textbf{Parent} & \textbf{Child}\\\hline
      Arathorn & Aragorn\\
      Drogo & Frodo\\
      E\"arwen & Galadriel\\
      Finarfin & Galadriel\\
      \rowcolor{white}
      \hfill\vdots & \hfill\vdots
    \end{tabular}
  \end{minipage}
  %
  %% \pause
  \hfill
  %
  \begin{minipage}{0.51\textwidth}
    %% TODO: is ``parentage'' the best name?
    \texttt{SELECT parent\\FROM parentage\\WHERE child = "Galadriel"}
  \end{minipage}
\end{frame}


\begin{frame}{Tables as sets}\large
  \begin{minipage}{0.4\textwidth}
    \centering
    \begin{tabular}{l|l}
      \textbf{Parent} & \textbf{Child}\\\hline
      Arathorn & Aragorn\\
      Drogo & Frodo\\
      E\"arwen & Galadriel\\
      Finarfin & Galadriel\\
      \rowcolor{white}
      \hfill\vdots & \hfill\vdots
    \end{tabular}

    %% \vspace{1.5em}{\large \uncover<2>{\textsc{as a table}}}

  \end{minipage}
  %
  \hfill{\LARGE =}\hfill
  %
  \begin{minipage}{0.51\textwidth}
    \centering

    \begin{tabular}{l}
      \color{gray}{// set of (parent, child) pairs}\\
      \{\hspace{1pt}("Arathorn", Aragorn)\\
      , (Drogo, Frodo)\\
      , (E\"arwen, Galadriel)\\
      , (Finarfin, Galadriel)\\
      \,...\,\} \phantom{\vdots}
    \end{tabular}

    %% \vspace{1.5em}{\large \textsc{as a relation}}
  \end{minipage}

\end{frame}


\begin{frame}{Queries as set comprehensions}\Large\centering
  \begin{minipage}{0.7\textwidth}
    \texttt{SELECT parent\\FROM parentage\\WHERE child = "Galadriel"}
  \end{minipage}

  \vspace{1.5em}
  {\LARGE $\Longrightarrow$}
  \vspace{1em}

  \begin{minipage}{1.0\textwidth}
    \df \tt \{ parent | (parent, child) in parentage\\
    \phantom{\{ parent }, child == "Galadriel" \}
  \end{minipage}
\end{frame}

\begin{frame}{Queries as set comprehensions: finding siblings}\large\centering
  \begin{minipage}{0.9\textwidth}
    \tt SELECT DISTINCT A.child, B.child\\
    FROM parentage A INNER JOIN parentage B\\
    ON A.parent = B.parent
    \\WHERE A.child <> B.child
  \end{minipage}

  \vspace{1.5em}
  {\LARGE $\Longrightarrow$}
  \vspace{1em}

  \begin{minipage}{0.8\textwidth}
    \df\tt\{ (a,b) | (parent, a) in parentage\\
    \phantom{\{ (a,b) }, (!parent, b) in parentage\\
    \phantom{\{ (a,b) }, not (a = b) \}
  \end{minipage}
\end{frame}


%% \begin{frame}{Queries as set comprehensions: grandparenting yourself}\large\centering
%%   \begin{minipage}{0.9\textwidth}
%%     \tt SELECT parent\\
%%     FROM parentage A INNER JOIN parentage B\\
%%     ON A.child = B.parent AND A.parent = B.child
%%   \end{minipage}

%%   \vspace{1.5em}
%%   {\LARGE $\Longrightarrow$}
%%   \vspace{1em}

%%   \begin{minipage}{0.8\textwidth}
%%     \df\tt\{ a | (a, b) in parentage\\
%%     \phantom{\{ a }, (!b, !a) in parentage \}
%%   \end{minipage}
%% \end{frame}


\begin{frame}{Recipe for a functional query language}\Large
  %% \textbf{Recipe for a functional query language:}\vspace{0.5em}

  \begin{enumerate}\itemsep 1.5em
  \item Take a functional language
  \item Add sets and set comprehensions
  \item {\color{red} ... done?}
  \end{enumerate}
\end{frame}


\begin{frame}\centering{\bf\huge But can it go fast?}\end{frame}

\begin{frame}{Loop reordering}\large\centering
  \texttt{\alt<1>{\df}{}\{ (x,y) | x in \alt<4>{{\color{red}\{\}}}{EXPR1},
    y in \alt<4>{{\color{red}$\infty$-loop}}{EXPR2}\alt<4>{}{,
    \alt<3>{{\color{red}print x}}{...}}\}}
  \alt<4>{{\color{blue}$~\Longrightarrow~$\{\}}\phantom{-loo}\,}{}
  %
  \vspace{0.5em}\\
  {\Large \alt<1>{=?}{\color{red}$\neq$}}
  %
  \vspace{0.5em}\\
  \texttt{\alt<1>{\df}{}\{ (x,y) | y in \alt<4>{{\color{red}$\infty$-loop}}{EXPR2},
    x in \alt<4>{{\color{red}\{\}}}{EXPR1}\alt<4>{}{,
    \alt<3>{{\color{red}print x}}{...}}\}}
  \alt<4>{{\color{blue}$~\Longrightarrow~\infty$-loop}}{}

  \pause
  \vspace{3em}\Large
  \begin{minipage}{0.5\textwidth}
    \begin{enumerate}
    \item {\alt<3>{\color{red}}{} Side-effects}
    \item {\alt<4>{\color{red}}{} Nontermination}
    \end{enumerate}
  \end{minipage}
\end{frame}


\begin{frame}{Recipe for a functional query language, v2}\Large
  \begin{enumerate}\itemsep 1.5em
  \item Take a \textbf{pure, total} functional language
  \item Add sets and set comprehensions
  \item {\color{orange} Optimize!}
  \end{enumerate}
\end{frame}


\begin{frame}{Pros and cons}
  
\end{frame}

%% TODO: slide about pros and cons / what we gained, what we lose
%% TODO: moar examples of Datafun


\begin{frame}\Large
  \begin{enumerate} \itemsep 1.5em \color{gray}
  \item What's a functional query language?
  \item {\color{black}\bf From Datalog to Datafun}
  \item Incremental Datafun
  \end{enumerate}
\end{frame}


\begin{frame} \large \centering
  \begin{minipage}{0.4\textwidth}
    \centering
    \begin{tabular}{l|l}
      \textbf{Parent} & \textbf{Child}\\\hline
      Arathorn & Aragorn\\
      Drogo & Frodo\\
      E\"arwen & Galadriel\\
      Finarfin & Galadriel\\
      \rowcolor{white}
      \hfill\vdots & \hfill\vdots
    \end{tabular}
  \end{minipage}

  \vspace{2em}

  %% robsimmons: ``It's worth having languages where the
  %% important ideas are foundational to the language.''
  %% use this?
  {\Large \bf Is E\"arendil one of Aragorn's ancestors?}

\end{frame}


\newcommand{\atom}[1]{\textcolor{brown}{#1}}
\begin{frame}{Datalog in a nutshell}
  \large
  \atom{\alt<2-3>{ancestor($X$,$Z$)}{$X$ is $Z$'s ancestor}}
  \alt<3>{:-}{if}
  \atom{\alt<2-3>{parent($X$, $Z$)}{$X$ is $Z$'s parent}}.
  \\\vspace{1em}
  \atom{\alt<2-3>{ancestor($X$, $Z$)}{$X$ is $Z$'s ancestor}}
  \alt<3>{:-}{if}
  \atom{\alt<2-3>{parent($X$, $Y$)}{$X$ is $Y$'s parent}}\alt<3>{,}{ and}
  \atom{\alt<2-3>{ancestor($Y$, $Z$)}{$Y$ is $Z$'s ancestor}}.

  %% \vspace{2em}
  %% \uncover<3>{\bf This is valid Datalog.}
\end{frame}

%% \begin{frame}\LARGE\centering
%%   \textbf{How can we do this\\ in a functional query language?}
%% \end{frame}


\begin{frame}\Large
  Datalog is \textbf{deductive}: it chases rules to their logical conclusions.
  \\\vspace{2em}
  Can we capture this feature \textbf{functionally}?
\end{frame}


\newcommand{\newfact}{\bf\color{Green}}
\newcommand{\used}{\bf\color{blue}}
\begin{frame}{}

  {
  \textbf{Procedure:}
  \begin{enumerate}\itemsep 0em
  \item Pick a rule.
  \item Find facts satisfying its premises.
  \item Add its conclusion to the known facts.
  \end{enumerate}}

  \textbf{Rules:}
  \begin{quote}\sf
    {\alt<2-4,6>{\used}{} ancestor(X,Z) :- parent(X,Z).}\\
    {\alt<8>{\used}{} ancestor(X,Z) :- parent(X,Y), ancestor(Y,Z).}\\
  \end{quote}

  \textbf{Facts:}
  \begin{quote}\sf
    {\alt<3-4,8>{\used}{} parent(Idril, E\"arendil).}\\
    {\alt<6>{\used}{} parent(E\"arendil, Elros).}\\
    \uncover<4->
    {\alt<4>{\newfact}{}ancestor(Idril, E\"arendil)\alt<4>{!}{.}}\\
    \uncover<6->
    {\alt<6>{\newfact}{}\alt<8>{\used}{}ancestor(E\"arendil, Elros)\alt<6>{!}{.}}\\
    \uncover<8->
    {\alt<8>{\newfact}{}{ancestor(Idril, Elros)\alt<8>{!}{.}}}
    \alt<9>{}{}
  \end{quote}
\end{frame}


\begin{frame}\Large
  Repeatedly apply a \textbf{\alt<2->{\alt<2>{\color{blue}}{}function}{set of rules}}\\
  until \textbf{\alt<3->{\alt<3>{\color{blue}}{}its output equals its input}{nothing changes}}\\
  \uncover<4->{i.e. it reaches a \textbf{\color{blue}fixed point}}{}

  \vspace{2em}

  \uncover<5->{\LARGE\centering\df fix x = {\it ... function of x ...}}
\end{frame}


\begin{frame}
  \Large

  \textcolor{gray}{\it // In Datalog}\\
  ancestor(X,Z) :- parent(X,Z).\\
  ancestor(X,Z) :- parent(X,Y), ancestor(Y,Z).

  \pause\vspace{2em}\df

  \textcolor{gray}{\it // In Datafun}\\
  fix ancestor = parent\newline
  \phantom{fix ancestor}
  %$\cup$ (parent $\bullet$ ancestor)
  $\cup$ \{(x,z) $\mid$ (x,y) in parent\newline
  \phantom{fix ancestor $\cup$ \{(x,z) }, (!y,z) in ancestor\}
\end{frame}


\begin{frame}\large
  \textbf{Repeatedly applying:}
  \begin{center}
    ${\color{blue}X} \longmapsto$ parent $\cup$ \{(x,z) $\mid$ (x,y) in parent, (!y,z) in {\color{blue}X}\}
  \end{center}

  \parskip 0.5em
  \textbf{Where} parent = \{(Idril, E\"arendil), (E\"arendil, Elros)\}

  \textbf{Steps}:\\
  \def\arraystretch{1.3}
  \begin{tabular}{rl}
    & \alt<1-2>{\color{blue}}{}$\emptyset$
    \\\pause
    $\longmapsto$ & parent $\cup$ \{(x,z) $\mid$ (x,y) in parent, (!y,z) in {\alt<1-2>{\color{blue}}{}$\emptyset$}\}
    \\\pause
    =& \alt<4>{\color{blue}}{}parent
    \\\pause
    $\longmapsto$ & parent $\cup$ \{(x,z) $\mid$ (x,y) in parent, (!y,z) in {\alt<4>{\color{blue}}{}parent}\}
    \\\pause
    =& \{(Idril, E\"arendil), (E\"arendil, Elros), (Idril, Elros)\}
  \end{tabular}
\end{frame}


\begin{frame}\centering{\bf\huge But can it go fast?}\end{frame}
% And I'm afraid the only answer I can give to this question is
% ``I don't know yet.''
%
% But I am hopeful. And in the next section I'm going to show you one of the
% reasons I'm hopeful.


\begin{frame}\Large
  \begin{enumerate}\color{gray}\itemsep 1.5em
  \item What's a functional query language?
  \item From Datalog to Datafun
  \item {\color{black}\bf Incremental Datafun}
  \end{enumerate}
\end{frame}


\begin{frame}{Three problems}\large
  \begin{enumerate}\itemsep 1em
    \alt<4>{\color{gray}}{}
  \item {\bf View maintenance:} \\
    {\normalsize How do we update a cached query efficiently after an update?}\
    \pause
  \item {\bf Semina\"ive evaluation in Datalog:}\\
    {\normalsize How to avoid applying rules that generate facts we already know?}
    \pause
  \item \color{black}{\bf Incremental computation:}\\
    {\normalsize How to efficiently recompute a
    function's output when its input changes slightly?}
  \end{enumerate}
\end{frame}

\begin{frame}
  \Large {\it ``A Theory of Changes for Higher-Order Languages:\\
    Incrementalizing $\lambda$-calculi by Static Differentiation''}
  \vspace{0.1em}\newline\normalsize [PLDI 2014]
  \\\vspace{0.5em}
  \small by Yufei Cai, Paolo G Giarrusso, Tillmann Rendel, and Klaus Ostermann
\end{frame}


\begin{frame}{Static differentiation: $\Delta$, $\oplus$, $\delta$}\large
  \vspace{-1em}
  Every type $A$ has a \emph{type of changes}, $\color{blue}\Delta A$.
  \pause
  \begin{eqnarray*}
    \GD \mathbb{N} &=& \mathbb{Z}\\
    \GD (A \x B) &=& \GD A \x \GD B
  \end{eqnarray*}

  \pause Every type also gets an operator $\color{blue}\oplus_A : A \to \GD A \to A$.
  \pause
  \begin{eqnarray*}
    x \oplus_\N dx &=& x + dx\\
    (x,y) \oplus_{A \x B} (dx,dy) &=& (x \oplus_A dx, y \oplus_B dy)
  \end{eqnarray*}

  \pause A function $f : A \to B$ gets a \emph{derivative},
  $\color{blue} \delta f : A \to \Delta A \to \Delta B$.
  \pause
  $$\begin{array}{rclcl}
    f(x) &=& x^2\\
    \delta f(x)(dx) &=& 2x\cdot dx+dx^2\\
    \pause
    f(x) + \delta f(x)(dx) &=& x^2 + 2x\cdot dx + dx^2 &=& (x + dx)^2
  \end{array}$$

  %% If $M$ uses variables $x, y, z$,\\
  %% then $\color{blue}\delta M$ will use $x, y, z, \color{blue} dx, dy, dz$.

  %% $\color{blue} \delta M$ computes the \emph{change to $M$}\\
  %% resulting from the changes $\color{blue} dx, dy, dz$ to its variables.

  %% \begin{eqnarray*}
  %% \Delta(A \x B) &=& \Delta A \x \Delta B\\
  %% \Delta(A \to B) &=& A \to \Delta A \to \Delta B
  %% \end{eqnarray*}
\end{frame}


\begin{frame}\centering\LARGE
  \textbf{We've extended this technique\\ to handle all of Datafun!}

  \vspace{1em}\small (As of about three weeks ago.)

\end{frame}


%% TODO:
\begin{frame}{Finding fixed points faster with derivatives}
  \large \parskip 1em
  The na\"ive way to find fixed points looks like this:
  $${\emptyset \mapsto f(\emptyset) \mapsto f^2(\emptyset) \mapsto f^3(\emptyset) \mapsto ...}$$
  \pause
  $f^i(\emptyset)$ and $f^{i+1}(\emptyset)$ \textbf{overlap a lot.}

  Computing $f^{i+1}(\emptyset)$ from $f^i(\emptyset)$ \textbf{does a lot of recomputation.}

  \pause
  What if we could only compute \textbf{what changed} between iterations?
\end{frame}

\begin{frame}\Large
  $$\begin{array}{lcl@{\hspace{2em}}lcl}
    x_0 &=& \emptyset
    & dx_0 &=& f(\emptyset)\\
    x_{i+1} &=& x_i \cup dx_i
    & dx_{i+1} &=& \delta f (x_i)(dx_i)\\
  \end{array}$$

  \vspace{1em}
  \textbf{Theorem:} $x_i = f^i(x)$
\end{frame}


%% conclusion
\begin{frame}{Takeaways}\large
  \begin{enumerate}\itemsep 1em
  \item Set comprehensions = queries
  \item Fixed points = recursive queries {\it\small (like Datalog)}
  \item Incremental computation = faster fixed points
  \item Datafun has all three!*
  \end{enumerate}

  \vspace{1em}\small
  * Almost.
\end{frame}

\begin{frame}\Large
  \textbf{Michael Arntzenius}\\
  \href{mailto:daekharel@gmail.com}{daekharel@gmail.com}\\
  \texttt{@arntzenius}

  \vspace{1em}
  \centering \huge \url{rntz.net/datafun}
\end{frame}

\end{document}
